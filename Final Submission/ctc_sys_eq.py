# -*- coding: utf-8 -*-
"""CTC_Systematic_Equities_Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/anaconda121/CTC/blob/main/CTC_Systematic_Equities_Notebook.ipynb
"""

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib as plt
from collections import defaultdict
import math
import matplotlib.pyplot as plt

"""# Systematic Equities Case Study"""

emerging_market_countries = ['BRA','MEX','IND','CHN','ZAF']
developed_market_countries = ['USA','JPN','DEU','GBR','FRA']

columns = ['Adj Close', 'Close', 'High', 'Low', 'Open', 'Volume'] # total data
features = ['Open', 'Close', 'High', 'Low', 'Volume'] # input features

# example of portfolio:
# keys: countries, values: array of five stock tickers.

portfolio = {
            'BRA': ['PBR','VALE','ITUB','NU','BSBR'],
            'MEX': ['AMX','KCDMY','VLRS','ALFAA.MX','BBAJIOO.MX'],
            'IND': ['RELIANCE.NS','TCS', 'HDB', 'INFY', 'ADANIENT.NS'],
            'USA': ['AAPL', 'MSFT','GOOG','AMZN','NVDA']
            }

stock_mapping = {}
for country in portfolio:
    for stock in portfolio[country]:
        stock_mapping[stock] = country

def get_data(portfolio, start_date, end_date):
    # Initialize an empty DataFrame
    data = pd.DataFrame()

    # Create an empty list for columns
    columns = []

    # Loop through each country in the portfolio
    for country, tickers in portfolio.items():
        # Download data for each ticker
        df = yf.download(tickers, start=start_date, end=end_date)

        # Extract the columns representing stock attributes (e.g., 'Adj Close', 'Volume', etc.)
        stock_attributes = df.columns.levels[0]

        # Extend the list of columns with country and attribute prefix
        country_columns = [(country, attr, ticker) for ticker in tickers for attr in stock_attributes]
        columns.extend(country_columns)

        # Concatenate the data to the main DataFrame
        data = pd.concat([data, df], axis=1)

    # Create a multi-index header
    data.columns = pd.MultiIndex.from_tuples(columns)
    return data

def generate_individal_equity_data(portfolio, data):
    equity_dfs = {}
    ticker_list = []

    for country in portfolio:
        for stock in portfolio[country]:
            df = pd.DataFrame(data.index) # initializing default df to have dates from 01-01-2023 -> 10-04-2023
            ticker_list.append(stock)
            for col in columns:
                col_data = data[country][col][stock].reset_index() # assigning equity data to df
                df[col] = col_data[stock]
            equity_dfs[stock] = df

    return equity_dfs

def generate_predicted_returns(df):
    # computing daily return
    daily_return_vals = []
    for i, row in df.iterrows():
        if (i == 0):
            daily_return_vals.append(0)
        else:
            ret = (df.loc[[i]]["EWMA-30"][i]) / (df.loc[[i-1]]["EWMA-30"][i-1]) - 1.00
            daily_return_vals.append(ret)

    # getting next day return to use as output feature
    next_day_return = []
    for i, row in df.iterrows():
        if (i == len(df) - 1):
            next_day_return.append(0)
        else:
            next_day_return.append(daily_return_vals[i + 1])

    return next_day_return

def run_strategy_sys_eq(data, portfolio, start_date, end_date):
    # data = get_data(portfolio, start_date=start_date, end_date=end_date)
    # data.interpolate(method = 'linear', inplace = True, limit_direction = 'both')
    equity_dfs = generate_individal_equity_data(portfolio, data)
    trading_list = pd.DataFrame(columns = data.columns.levels[2])

    for ticker in data.columns.levels[2]:
        curr_data = equity_dfs[ticker]
        curr_data["EWMA-30"] = curr_data["Adj Close"].ewm(span = 30).mean()
        curr_data["EWMA-30"] = curr_data["EWMA-30"].shift(1)
        curr_data["Next Day Returns"] = generate_predicted_returns(curr_data)
        ticker_trades = pd.DataFrame(columns = [ticker])

        row_counter = 0
        for dates in curr_data["Date"]:
            if curr_data.loc[[row_counter]]["Next Day Returns"][row_counter] > 0:
                ticker_trades.loc[dates] = 1
            else:
                ticker_trades.loc[dates] = -1
            row_counter += 1

        trading_list[ticker] = ticker_trades

    trading_list_one = trading_list.sub(trading_list.mean(axis=1), axis=0)
    trading_list_normalized = trading_list_one.div(trading_list_one.abs().sum(axis=1), axis=0)
    return trading_list_normalized

def private_test_deriv():
    start_date = "2015-01-01"
    end_date = "2023-01-01"
    data = get_data(portfolio, start_date, end_date)
    data.interpolate(method = 'linear', inplace = True, limit_direction = 'both')
    res_dataframe = run_strategy_sys_eq(data, portfolio, start_date,end_date)
    return res_dataframe

private_test_deriv()